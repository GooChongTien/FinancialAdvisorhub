import React, { useEffect, useMemo, useRef, useState } from "react";
import * as d3 from "d3";
import { Play, Pause, RotateCcw, Download, Upload, Save, Plus, Edit2, Trash2, TrendingUp, TrendingDown, DollarSign, Calendar } from "lucide-react";

/**
 * Cashflow Visualizer — React + D3 (stabilized)
 *
 * Fixes
 * - Resolves SyntaxError (unterminated string) from an incomplete JSX line.
 * - Fixes "Unexpected token, expected ," by completing the event handlers and effect blocks.
 * - Prevents React error #130 by validating/guarding props and refs for child components.
 * - Ensures `rows` is always an array and numbers are valid before rendering.
 * - Places x-axis at y=0; years render as 2025 (no commas); balance dots have no stroke.
 * - Outflow category "Investment" is teal and ordered under Closing Balance; divider "Other Outflows" retained.
 * - Closing Balance of 0 renders a thin labeled bar.
 *
 * Tests
 * - Preserves earlier runtime tests and adds more to cover edge-cases.
 */

// ---------- Constants ----------
const SPEEDS_MS: Record<string, number> = { slow: 2000, normal: 1000, fast: 500 };
const STORAGE_KEY = "cashflow-visualizer-state-v1";

const INFLOW_CATEGORIES = [
  "Active Income",
  "Dividend",
  "Passive Income",
  "Business",
  "Rental",
  "Other",
] as const;

const OUTFLOW_CATEGORIES = [
  "Expenses",
  "Installment",
  "Investment",
  "Tax",
  "Other",
] as const;

// ---------- Types ----------
export type Item = {
  id: string;
  type: "inflow" | "outflow";
  category: (typeof INFLOW_CATEGORIES[number]) | (typeof OUTFLOW_CATEGORIES[number]) | string;
  name: string;
  value: number; // amount per period
  rate: number; // annual % (return for inflow, interest for outflow)
  period: "Monthly" | "Annually";
  frequency: "Recurring" | "One-off";
  startYear: number;
  endYear: number | null; // Recurring only
};

// ---------- Utilities ----------
function cryptoRandomId() {
  try {
    // @ts-ignore
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
      const arr = new Uint32Array(3);
      // @ts-ignore
      crypto.getRandomValues(arr);
      return Array.from(arr, (n) => n.toString(36)).join("");
    }
  } catch {}
  return Math.random().toString(36).slice(2) + Date.now().toString(36);
}

export function isActiveInYear(it: Item, year: number): boolean {
  if (year < it.startYear) return false;
  if (it.frequency === "One-off") return year === it.startYear;
  if (it.endYear == null) return true; // Recurring, no end
  return year <= it.endYear; // inclusive end
}

export function grownValueAtYear(it: Item, year: number): number {
  const years = Math.max(0, year - it.startYear);
  const annual = it.value * (it.period === "Monthly" ? 12 : 1);
  return annual * Math.pow(1 + (it.rate || 0) / 100, years);
}

export function aggregateByYear(items: Item[], year: number) {
  const actives = (items || []).filter((it) => isActiveInYear(it, year));
  const inflowItems = actives
    .filter((i) => i.type === "inflow")
    .map((i) => ({ ...i, calculatedValue: grownValueAtYear(i, year) }));
  const outflowItems = actives
    .filter((i) => i.type === "outflow")
    .map((i) => ({ ...i, calculatedValue: grownValueAtYear(i, year) }));

  const totalInflows = inflowItems.reduce((s, i: any) => s + i.calculatedValue, 0);
  const totalOutflows = outflowItems.reduce((s, i: any) => s + i.calculatedValue, 0);
  const outflowsInvestment = outflowItems
    .filter((i) => i.category === "Investment")
    .reduce((s, i: any) => s + i.calculatedValue, 0);
  const outflowsOther = totalOutflows - outflowsInvestment;
  const netCash = totalInflows - totalOutflows;
  return { inflowItems, outflowItems, totalInflows, totalOutflows, outflowsInvestment, outflowsOther, netCash };
}

// ---------- Runtime tests ----------
(function devTests() {
  const y = 2022;
  const inflow: Item = { id: "i", type: "inflow", category: "Active Income", name: "Salary", value: 1000, rate: 0, period: "Monthly", frequency: "Recurring", startYear: y, endYear: y + 1 };
  const inv: Item = { id: "o1", type: "outflow", category: "Investment", name: "DCA", value: 100, rate: 0, period: "Monthly", frequency: "Recurring", startYear: y, endYear: y + 1 };
  const exp: Item = { id: "o2", type: "outflow", category: "Expenses", name: "Rent", value: 200, rate: 0, period: "Monthly", frequency: "Recurring", startYear: y, endYear: y + 1 };

  console.assert(isActiveInYear(inflow, y) && isActiveInYear(inflow, y + 1) && !isActiveInYear(inflow, y + 2), "isActiveInYear endYear inclusive failed");
  console.assert(grownValueAtYear(inflow, y) === 12000, "annualization failed");
  const a0 = aggregateByYear([inflow, inv, exp], y);
  console.assert(a0.totalInflows === 12000, "totalInflows calc failed");
  console.assert(a0.totalOutflows === (100 + 200) * 12, "totalOutflows calc failed");
  console.assert(a0.outflowsInvestment === 1200, "investment split failed");
  console.assert(a0.outflowsOther === 2400, "other split failed");
})();

(function devTestsBalance() {
  const base = 2020;
  const xs: Item[] = [
    { id: "a", type: "inflow", category: "Active Income", name: "A", value: 100, rate: 0, period: "Monthly", frequency: "Recurring", startYear: base, endYear: base + 2 },
    { id: "b", type: "outflow", category: "Expenses", name: "B", value: 40, rate: 0, period: "Monthly", frequency: "Recurring", startYear: base, endYear: base + 2 },
  ];
  let run = 0; const out: number[] = [];
  for (let y = base; y <= base + 2; y++) { const c = aggregateByYear(xs, y); run += c.totalInflows - c.totalOutflows; out.push(run); }
  console.assert(out[0] === 720 && out[1] === 1440 && out[2] === 2160, "cumulative balance failed");
})();

// Extra tests: zero/empty safety
(function devTestsSafety() {
  const y = 2030;
  const a0 = aggregateByYear([], y);
  console.assert(a0.totalInflows === 0 && a0.totalOutflows === 0 && a0.netCash === 0, "empty aggregate safety failed");
})();

// ---------- Main Component ----------
export default function CashflowVisualizer() {
  const systemYear = new Date().getFullYear();

  // State
  const [items, setItems] = useState<Item[]>([]);
  const [currentYear, setCurrentYear] = useState<number>(systemYear);
  const [endYear, setEndYear] = useState<number>(systemYear + 10);
  const [isPlaying, setIsPlaying] = useState<boolean>(false);
  const [speed, setSpeed] = useState<"slow" | "normal" | "fast">("normal");
  const [showModal, setShowModal] = useState<boolean>(false);
  const [editing, setEditing] = useState<Item | null>(null);

  // Refs
  const sankeyRef = useRef<HTMLDivElement | null>(null);
  const chartRef = useRef<HTMLDivElement | null>(null);

  // Load/Save
  useEffect(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        if (Array.isArray(parsed?.items)) setItems(parsed.items);
        if (typeof parsed?.endYear === "number") setEndYear(parsed.endYear);
      }
    } catch {}
  }, []);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ items, endYear }));
  }, [items, endYear]);

  // Animation
  useEffect(() => {
    if (!isPlaying) return;
    if (currentYear >= endYear) { setIsPlaying(false); return; }
    const id = setInterval(() => setCurrentYear((y) => Math.min(y + 1, endYear)), SPEEDS_MS[speed]);
    return () => clearInterval(id);
  }, [isPlaying, speed, currentYear, endYear]);

  // Per-year for currentYear
  const { inflowItems, outflowItems, totalInflows, totalOutflows } = useMemo(() => {
    const c = aggregateByYear(items, currentYear);
    return { inflowItems: c.inflowItems, outflowItems: c.outflowItems, totalInflows: c.totalInflows, totalOutflows: c.totalOutflows };
  }, [items, currentYear]);

  // Series across years
  const series = useMemo(() => {
    const rows: { year: number; inflows: number; outflows: number; outflowsInvestment: number; outflowsOther: number; balance: number }[] = [];
    let running = 0;
    for (let y = systemYear; y <= endYear; y++) {
      const c = aggregateByYear(items, y);
      running += c.totalInflows - c.totalOutflows;
      rows.push({ year: y, inflows: c.totalInflows, outflows: c.totalOutflows, outflowsInvestment: c.outflowsInvestment, outflowsOther: c.outflowsOther, balance: running });
    }
    return rows;
  }, [items, endYear, systemYear]);

  const balance = useMemo(() => series.find((r) => r.year === currentYear)?.balance ?? 0, [series, currentYear]);
  const prevBalance = useMemo(() => series.find((r) => r.year === currentYear - 1)?.balance ?? 0, [series, currentYear]);

  // Preset
  function presetData() {
    return {
      items: [
        { id: cryptoRandomId(), type: "inflow",  category: "Active Income", name: "Salary",          value: 5000, rate: 3,  period: "Monthly",  frequency: "Recurring", startYear: systemYear, endYear: null },
        { id: cryptoRandomId(), type: "inflow",  category: "Dividend",      name: "ETF Dividends",   value: 2000, rate: 2,  period: "Annually", frequency: "Recurring", startYear: systemYear, endYear: null },
        { id: cryptoRandomId(), type: "outflow", category: "Investment",    name: "Index Fund DCA",  value: 800,  rate: 0,  period: "Monthly",  frequency: "Recurring", startYear: systemYear, endYear: null },
        { id: cryptoRandomId(), type: "outflow", category: "Expenses",      name: "Living Expenses", value: 3500, rate: 2,  period: "Monthly",  frequency: "Recurring", startYear: systemYear, endYear: null },
      ] as Item[],
      endYear: systemYear + 10,
    };
  }
  function usePreset() { const p = presetData(); setItems(p.items); setEndYear(p.endYear); setCurrentYear(systemYear); }
  function resetToPreset() { usePreset(); }

  // Import/Export
  function exportJSON() {
    const payload = { items, endYear };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href = url; a.download = `cashflow-data-${new Date().toISOString().slice(0, 10)}.json`; a.click(); URL.revokeObjectURL(url);
  }
  function importFromFile(e: React.ChangeEvent<HTMLInputElement>) {
    const file = e.target.files?.[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try { const data = JSON.parse(String(ev.target?.result || "{}")); if (Array.isArray(data.items)) setItems(data.items); if (data.endYear) setEndYear(Number(data.endYear)); }
      catch { alert("Invalid JSON"); }
    };
    reader.readAsText(file);
    e.currentTarget.value = "";
  }

  // CRUD
  function beginAdd() {
    setEditing({ id: cryptoRandomId(), type: "inflow", category: "Active Income", name: "", value: 0, rate: 0, period: "Monthly", frequency: "Recurring", startYear: systemYear, endYear: null });
    setShowModal(true);
  }
  function beginEdit(row: Item) { setEditing({ ...row }); setShowModal(true); }
  function removeItem(id: string) { setItems((xs) => xs.filter((x) => x.id !== id)); }
  function saveItem() {
    if (!editing) return;
    const e = editing;
    if (!e.name || !e.category || !e.type || !e.period) return alert("Please complete the form.");
    if (e.value <= 0) return alert("Value must be > 0.");
    setItems((xs) => {
      const idx = xs.findIndex((x) => x.id === e.id);
      if (idx >= 0) { const clone = xs.slice(); clone[idx] = e; return clone; }
      return [...xs, e];
    });
    setShowModal(false); setEditing(null);
  }

  // UI
  return (
    <div className="min-h-screen w-full bg-gradient-to-br from-indigo-950 via-purple-950 to-slate-900 text-white p-4 sm:p-6">
      <header className="text-center mb-6">
        <h1 className="text-4xl sm:text-5xl font-bold text-yellow-300 mb-2">Cashflow Visualizer</h1>
        <p className="text-gray-300">Project your inflows & outflows; see balance over time</p>
      </header>

      {/* Controls */}
      <section className="bg-slate-800/50 backdrop-blur rounded-xl p-3 sm:p-4 mb-6 flex flex-wrap items-center gap-3">
        <button
          onClick={() => setIsPlaying((v) => !v)}
          className="flex items-center gap-2 px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg transition-colors"
        >
          {isPlaying ? <Pause size={18} /> : <Play size={18} />}
          {isPlaying ? "Pause" : "Play"}
        </button>

        <button
          onClick={() => setCurrentYear(systemYear)}
          className="flex items-center gap-2 px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg transition-colors"
          title="Reset to current year"
        >
          <RotateCcw size={18} />
        </button>

        <div className="flex items-center gap-2">
          <span className="text-sm text-gray-400">Speed</span>
          <select
            value={speed}
            onChange={(e) => setSpeed(e.target.value as any)}
            className="px-3 py-2 bg-slate-700 rounded-lg border border-slate-600 text-sm"
          >
            <option value="slow">Slow</option>
            <option value="normal">Normal</option>
            <option value="fast">Fast</option>
          </select>
        </div>

        <div className="flex items-center gap-2">
          <span className="text-sm text-gray-400">End Year</span>
          <input
            type="number"
            value={endYear}
            onChange={(e) => setEndYear(Math.max(systemYear, Number(e.target.value) || systemYear))}
            className="px-3 py-2 bg-slate-700 rounded-lg border border-slate-600 w-28"
          />
        </div>

        <button onClick={usePreset} className="flex items-center gap-2 px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors">
          <Save size={18} />
          Preset
        </button>

        <button onClick={resetToPreset} className="flex items-center gap-2 px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors">
          <RotateCcw size={18} />
          Reset Preset
        </button>

        <button onClick={exportJSON} className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors">
          <Download size={18} />
          Export
        </button>

        <label className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors cursor-pointer">
          <Upload size={18} />
          Import
          <input type="file" accept=".json" onChange={importFromFile} className="hidden" />
        </label>
      </section>

      {/* Main grid: Sankey + Chart */}
      <section className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        <Panel title="Your Cash Flow">
          {items.length > 0 ? (
            <SankeyDiagram
              refEl={sankeyRef}
              inflowItems={inflowItems}
              outflowItems={outflowItems}
              totalInflows={totalInflows}
              totalOutflows={totalOutflows}
              balance={balance}
              prevBalance={prevBalance}
            />
          ) : (
            <EmptyViz text="Add items to see cash flow visualization" />
          )}

          {/* Summary cards */}
          <div className="mt-4 bg-slate-900/40 rounded-lg p-4 border border-slate-700">
            <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
              <SummaryCard icon={<TrendingUp size={20} className="text-emerald-400" />} title="Inflows" value={`$${Math.round(totalInflows).toLocaleString()}`} boxClass="bg-emerald-600/20 border-emerald-500/30" textClass="text-emerald-400" />
              <SummaryCard icon={<TrendingDown size={20} className="text-rose-400" />} title="Outflows" value={`$${Math.round(totalOutflows).toLocaleString()}`} boxClass="bg-rose-600/20 border-rose-500/30" textClass="text-rose-400" />
              <SummaryCard icon={<DollarSign size={20} className="text-amber-400" />} title={balance >= 0 ? "Closing Balance" : "Deficit"} value={`${balance >= 0 ? "$" : "-$"}${Math.abs(Math.round(balance)).toLocaleString()}`} boxClass="bg-amber-600/20 border-amber-500/30" textClass="text-amber-400" />
              <SummaryCard icon={<Calendar size={20} className="text-blue-400" />} title="Year" value={`${currentYear}`} boxClass="bg-blue-600/20 border-blue-500/30" textClass="text-blue-400" />
            </div>
          </div>
        </Panel>

        <Panel title="Your Balance Projection">
          {items.length > 0 ? (
            <ProjectionChart
              refEl={chartRef}
              rows={series}
              currentYear={currentYear}
              startYear={systemYear}
              endYear={endYear}
              interactive={!isPlaying}
              onYearSelect={(y) => !isPlaying && setCurrentYear(y)}
            />
          ) : (
            <EmptyViz text="Add items to see balance projection" />
          )}
        </Panel>
      </section>

      {/* Manager */}
      <section className="bg-slate-800/50 backdrop-blur rounded-xl p-6">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-2xl font-bold">Inflow & Outflow Manager</h2>
          <button onClick={beginAdd} className="flex items-center gap-2 px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg transition-colors">
            <Plus size={18} /> Add Item
          </button>
        </div>

        {items.length === 0 ? (
          <p className="text-gray-400 text-center py-10">No items yet. Click “Add Item” or “Preset”.</p>
        ) : (
          <div className="space-y-3">
            {items.map((it) => (
              <div key={it.id} className="bg-slate-700/50 rounded-lg p-4 flex items-center justify-between hover:bg-slate-700 transition-colors">
                <div className="flex items-center gap-4">
                  <span className={`w-3 h-3 rounded-full ${it.type === "inflow" ? "bg-green-500" : it.category === "Investment" ? "bg-teal-400" : "bg-red-500"}`} />
                  <div>
                    <div className="flex items-center gap-2">
                      <span className="font-semibold text-lg">{it.name || (it.type === "inflow" ? "Inflow" : "Outflow")}</span>
                      <span className="text-sm text-gray-400">({it.category})</span>
                    </div>
                    <div className="text-sm text-gray-400">
                      ${it.value.toLocaleString()} • {it.rate}% • {it.period} • {it.frequency} • {it.startYear}
                      {it.frequency === "Recurring" && it.endYear ? ` - ${it.endYear}` : ""}
                    </div>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  <button onClick={() => beginEdit(it)} className="p-2 hover:bg-slate-600 rounded-lg"><Edit2 size={18} /></button>
                  <button onClick={() => removeItem(it.id)} className="p-2 hover:bg-slate-600 rounded-lg text-red-400"><Trash2 size={18} /></button>
                </div>
              </div>
            ))}
          </div>
        )}
      </section>

      {showModal && editing && (
        <Modal onClose={() => { setShowModal(false); setEditing(null); }}>
          <h3 className="text-2xl font-bold mb-1">{items.find((x) => x.id === editing.id) ? "Edit Item" : "Add Item"}</h3>
          <p className="text-gray-400 mb-4">Fill in the details of your inflow or outflow.</p>

          {/* Form */}
          <div className="space-y-4">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium mb-2">Type</label>
                <select
                  value={editing.type}
                  onChange={(e) => setEditing((prv) => ({
                    ...(prv as Item),
                    type: e.target.value as Item["type"],
                    category: e.target.value === "inflow" ? "Active Income" : "Expenses",
                  }))}
                  className="w-full px-4 py-2 bg-slate-700 rounded-lg border border-cyan-500"
                >
                  <option value="inflow">Inflow</option>
                  <option value="outflow">Outflow</option>
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium mb-2">Category</label>
                <select
                  value={editing.category}
                  onChange={(e) => setEditing((prv) => ({ ...(prv as Item), category: e.target.value }))}
                  className="w-full px-4 py-2 bg-slate-700 rounded-lg border border-slate-600"
                >
                  {(editing.type === "inflow" ? INFLOW_CATEGORIES : OUTFLOW_CATEGORIES).map((c) => (
                    <option key={c} value={c}>{c}</option>
                  ))}
                </select>
              </div>
            </div>

            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium mb-2">Name</label>
                <input
                  type="text"
                  value={editing.name}
                  onChange={(e) => setEditing((prv) => ({ ...(prv as Item), name: e.target.value }))}
                  className="w-full px-4 py-2 bg-slate-700 rounded-lg border border-slate-600"
                  placeholder="e.g., Salary, Rent, DCA"
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-2">Amount ($)</label>
                <input
                  type="number"
                  value={editing.value}
                  onChange={(e) => setEditing((prv) => ({ ...(prv as Item), value: Number(e.target.value) }))}
                  className="w-full px-4 py-2 bg-slate-700 rounded-lg border border-slate-600"
                />
              </div>
            </div>

            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium mb-2">Period</label>
                <select
                  value={editing.period}
                  onChange={(e) => setEditing((prv) => ({ ...(prv as Item), period: e.target.value as Item["period"] }))}
                  className="w-full px-4 py-2 bg-slate-700 rounded-lg border border-slate-600"
                >
                  <option>Monthly</option>
                  <option>Annually</option>
                </select>
              </div>
              <div>
                <label className="block text sm font-medium mb-2">{editing.type === "inflow" ? "Annual Return (%)" : "Annual Interest (%)"}</label>
                <input
                  type="number"
                  step="0.1"
                  value={editing.rate}
                  onChange={(e) => setEditing((prv) => ({ ...(prv as Item), rate: Number(e.target.value) }))}
                  className="w-full px-4 py-2 bg-slate-700 rounded-lg border border-slate-600"
                />
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium mb-2">Frequency</label>
              <select
                value={editing.frequency}
                onChange={(e) => setEditing((prv) => ({ ...(prv as Item), frequency: e.target.value as Item["frequency"] }))}
                className="w-full px-4 py-2 bg-slate-700 rounded-lg border border-slate-600"
              >
                <option>Recurring</option>
                <option>One-off</option>
              </select>
            </div>

            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium mb-2">Start Year</label>
                <input
                  type="number"
                  value={editing.startYear}
                  onChange={(e) => setEditing((prv) => ({ ...(prv as Item), startYear: Number(e.target.value) }))}
                  className="w-full px-4 py-2 bg-slate-700 rounded-lg border border-slate-600"
                />
              </div>
              {editing.frequency === "Recurring" && (
                <div>
                  <label className="block text-sm font-medium mb-2">End Year (optional)</label>
                  <input
                    type="number"
                    value={editing.endYear ?? ""}
                    onChange={(e) => setEditing((prv) => ({ ...(prv as Item), endYear: e.target.value ? Number(e.target.value) : null }))}
                    className="w-full px-4 py-2 bg-slate-700 rounded-lg border border-slate-600"
                  />
                </div>
              )}
            </div>

            <div className="flex gap-3 pt-2">
              <button onClick={saveItem} className="flex-1 px-4 py-3 bg-green-600 hover:bg-green-700 rounded-lg font-medium">Save</button>
              <button onClick={() => { setShowModal(false); setEditing(null); }} className="px-6 py-3 bg-slate-700 hover:bg-slate-600 rounded-lg font-medium">Cancel</button>
            </div>
          </div>
        </Modal>
      )}
    </div>
  );
}

// ---------- UI Fragments ----------
function Panel({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <div className="bg-slate-800/50 backdrop-blur rounded-xl p-4 sm:p-6">
      <h2 className="text-xl font-bold mb-4">{title}</h2>
      {children}
    </div>
  );
}

function EmptyViz({ text }: { text: string }) {
  return <div className="h-96 flex items-center justify-center text-gray-400">{text}</div>;
}

function SummaryCard({ icon, title, value, boxClass, textClass }: { icon: React.ReactNode; title: string; value: string; boxClass: string; textClass: string; }) {
  return (
    <div className="flex items-center gap-3">
      <div className={`p-2.5 rounded-lg border ${boxClass}`}>{icon}</div>
      <div>
        <div className="text-xs text-gray-400 uppercase tracking-wide mb-0.5">{title}</div>
        <div className={`text-2xl font-bold ${textClass}`}>{value}</div>
      </div>
    </div>
  );
}

function Modal({ children, onClose }: { children: React.ReactNode; onClose: () => void }) {
  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
      <div className="bg-slate-800 rounded-xl p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
        <div className="flex justify-end">
          <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl leading-none">×</button>
        </div>
        {children}
      </div>
    </div>
  );
}

// ---------- Sankey ----------
function SankeyDiagram({ refEl, inflowItems = [], outflowItems = [], totalInflows = 0, totalOutflows = 0, balance = 0, prevBalance = 0 }:{
  refEl: React.RefObject<HTMLDivElement>;
  inflowItems: (Item & { calculatedValue: number })[];
  outflowItems: (Item & { calculatedValue: number })[];
  totalInflows: number; totalOutflows: number; balance: number; prevBalance: number; }) {
  useEffect(() => {
    const el = refEl?.current; if (!el) return;
    const width = Math.max(320, el.clientWidth || 800);
    const height = 460;
    const margin = { top: 24, right: 120, bottom: 24, left: 120 };

    d3.select(el).selectAll('*').remove();
    const svg = d3.select(el).append('svg').attr('width', width).attr('height', height);
    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
    const w = width - margin.left - margin.right;
    const h = height - margin.top - margin.bottom;

    // Columns
    const nodeWidth = 64;
    const colLeftX = 0;
    const colCenterX = w / 2 - nodeWidth / 2;
    const colRightX = w - nodeWidth;

    // Identity: Opening + Inflows = Total Cash = Closing/Deficit + Outflows
    const totalCash = prevBalance + totalInflows;
    const prevAbs = Math.abs(prevBalance);
    const balAbs = Math.abs(balance);

    const maxVal = Math.max(
      1,
      prevAbs,
      Math.abs(totalCash),
      balAbs,
      totalInflows,
      totalOutflows,
      ...outflowItems.map((x) => x.calculatedValue),
      ...inflowItems.map((x) => x.calculatedValue)
    );
    const scaleH = d3.scaleLinear().domain([0, maxVal]).range([0, h * 0.75]);

    // LEFT: Opening + inflows
    let yCursor = 16;
    const hasPrev = prevAbs > 0;
    const prevNode = hasPrev
      ? { name: prevBalance >= 0 ? "Opening Balance" : "Opening Deficit", x: colLeftX, y: yCursor, width: nodeWidth, height: Math.max(18, scaleH(prevAbs)), value: prevAbs, color: prevBalance >= 0 ? "#f1c40f" : "#ff6b6b" }
      : null as any;
    if (hasPrev) yCursor += (prevNode as any).height + 14;

    const inflowNodes = inflowItems.map((it) => {
      const nh = Math.max(18, scaleH(it.calculatedValue));
      const node = { ...it, x: colLeftX, y: yCursor, width: nodeWidth, height: nh, color: "#10ac84" };
      yCursor += nh + 14;
      return node;
    });

    // CENTER: Total Cash
    const centerH = Math.max(20, scaleH(Math.abs(totalCash)));
    const centerNode = { name: "Total Cash", x: colCenterX, y: h / 2 - centerH / 2, width: nodeWidth, height: centerH, value: totalCash, color: "#f1c40f" };

    // RIGHT: Balance then Investment (teal) then divider then Others (red)
    let rightY = 16;
    const rightPrimaryNode = { name: balance >= 0 ? "Closing Balance" : "Deficit", x: colRightX, y: rightY, width: nodeWidth, height: Math.max(6, scaleH(balAbs)), value: balAbs, color: balance >= 0 ? "#f1c40f" : "#ff6b6b" };
    rightY += rightPrimaryNode.height + 14;

    const investmentOutflows = outflowItems.filter((it) => it.category === "Investment");
    const otherOutflows = outflowItems.filter((it) => it.category !== "Investment");
    const outflowNodes: any[] = [];

    investmentOutflows.forEach((it) => {
      const nh = Math.max(18, scaleH(it.calculatedValue));
      const node = { ...it, x: colRightX, y: rightY, width: nodeWidth, height: nh, color: "#14b8a6" };
      rightY += nh + 14;
      outflowNodes.push(node);
    });

    if (investmentOutflows.length > 0 && otherOutflows.length > 0) {
      g.append('text')
        .attr('x', colRightX + nodeWidth / 2)
        .attr('y', rightY + 4)
        .attr('text-anchor', 'middle')
        .attr('fill', '#9ca3af')
        .attr('font-size', 11)
        .attr('font-style', 'italic')
        .text('Other Outflows');
      rightY += 16;
    }

    otherOutflows.forEach((it) => {
      const nh = Math.max(18, scaleH(it.calculatedValue));
      const node = { ...it, x: colRightX, y: rightY, width: nodeWidth, height: nh, color: "#ff6b6b" };
      rightY += nh + 14;
      outflowNodes.push(node);
    });

    // LINKS
    const links: any[] = [];
    if (prevNode) links.push({ source: prevNode, target: centerNode, value: (prevNode as any).value, color: (prevNode as any).color });
    inflowNodes.forEach((n) => links.push({ source: n, target: centerNode, value: n.calculatedValue, color: "#10ac84" }));
    links.push({ source: centerNode, target: rightPrimaryNode, value: balAbs, color: rightPrimaryNode.color });
    outflowNodes.forEach((n) => links.push({ source: centerNode, target: n, value: n.calculatedValue, color: n.color }));

    links.forEach((lk) => {
      const sx = lk.source.x + lk.source.width;
      const sy = lk.source.y + lk.source.height / 2;
      const tx = lk.target.x;
      const ty = lk.target.y + lk.target.height / 2;
      const cx = (sx + tx) / 2;
      const path = `M ${sx} ${sy} C ${cx} ${sy}, ${cx} ${ty}, ${tx} ${ty}`;
      g.append('path')
        .attr('d', path)
        .attr('fill', 'none')
        .attr('stroke', lk.color)
        .attr('stroke-width', Math.max(2, scaleH(lk.value)))
        .attr('opacity', 0.4);
    });

    function drawNode(node: any, label: string) {
      const grp = g.append('g');
      grp
        .append('rect')
        .attr('x', node.x)
        .attr('y', node.y)
        .attr('width', node.width)
        .attr('height', node.height)
        .attr('fill', node.color)
        .attr('rx', 6)
        .attr('opacity', 0.85);

      const isLeft = node.x < w / 2;
      grp
        .append('text')
        .attr('x', isLeft ? node.x - 10 : node.x + node.width + 10)
        .attr('y', node.y + node.height / 2)
        .attr('dy', '0.35em')
        .attr('text-anchor', isLeft ? 'end' : 'start')
        .attr('fill', '#e5e7eb')
        .attr('font-size', 12)
        .text(label);

      grp
        .append('text')
        .attr('x', node.x + node.width / 2)
        .attr('y', node.y + node.height / 2)
        .attr('dy', '0.35em')
        .attr('text-anchor', 'middle')
        .attr('fill', '#fff')
        .attr('font-weight', 700)
        .attr('font-size', 11)
        .text(`$${(((typeof node.calculatedValue === 'number') ? node.calculatedValue : node.value) ?? 0).toLocaleString(undefined, { maximumFractionDigits: 0 })}`);
    }

    if (prevNode) drawNode(prevNode, (prevNode as any).name);
    inflowNodes.forEach((n) => drawNode(n, n.name));
    drawNode({ ...centerNode, value: totalCash }, 'Total Cash');
    drawNode(rightPrimaryNode, rightPrimaryNode.name);
    outflowNodes.forEach((n) => drawNode(n, n.name));
  }, [refEl, inflowItems, outflowItems, totalInflows, totalOutflows, balance, prevBalance]);

  return <div ref={refEl} className="w-full" />;
}

// ---------- Projection Chart ----------
function ProjectionChart({ refEl, rows, currentYear, startYear, endYear, interactive = false, onYearSelect }:{
  refEl: React.RefObject<HTMLDivElement>;
  rows: { year:number; inflows:number; outflows:number; outflowsInvestment:number; outflowsOther:number; balance:number }[];
  currentYear:number; startYear:number; endYear:number; interactive?:boolean; onYearSelect?:(y:number)=>void; }) {
  useEffect(() => {
    const el = refEl?.current; if (!el) return;

    const width = Math.max(320, el.clientWidth || 800);
    const height = 420;
    const margin = { top: 24, right: 64, bottom: 56, left: 80 };

    d3.select(el).selectAll('*').remove();
    const svg = d3.select(el).append('svg').attr('width', width).attr('height', height);

    const w = width - margin.left - margin.right;
    const h = height - margin.top - margin.bottom;
    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

    // Gradients
    const defs = svg.append('defs');
    const gradInfl = defs.append('linearGradient').attr('id', 'gradInfl').attr('x1', '0%').attr('y1', '0%').attr('x2', '0%').attr('y2', '100%');
    gradInfl.append('stop').attr('offset', '0%').attr('stop-color', '#10b981').attr('stop-opacity', 0.8);
    gradInfl.append('stop').attr('offset', '100%').attr('stop-color', '#10b981').attr('stop-opacity', 0.2);

    const gradInv = defs.append('linearGradient').attr('id', 'gradInv').attr('x1', '0%').attr('y1', '0%').attr('x2', '0%').attr('y2', '100%');
    gradInv.append('stop').attr('offset', '0%').attr('stop-color', '#14b8a6').attr('stop-opacity', 0.2);
    gradInv.append('stop').attr('offset', '100%').attr('stop-color', '#14b8a6').attr('stop-opacity', 0.8);

    const gradOut = defs.append('linearGradient').attr('id', 'gradOut').attr('x1', '0%').attr('y1', '0%').attr('x2', '0%').attr('y2', '100%');
    gradOut.append('stop').attr('offset', '0%').attr('stop-color', '#ef4444').attr('stop-opacity', 0.2);
    gradOut.append('stop').attr('offset', '100%').attr('stop-color', '#ef4444').attr('stop-opacity', 0.8);

    // Scales
    const x = d3.scaleLinear().domain([startYear, endYear]).range([0, w]);
    const maxPos = d3.max(rows, (d) => Math.max(d.inflows, d.balance)) ?? 1;
    const maxNeg = d3.max(rows, (d) => Math.max(d.outflowsInvestment + d.outflowsOther, 0)) ?? 0; // below zero
    const y = d3.scaleLinear().domain([Math.min(-maxNeg * 1.15, 0), Math.max(maxPos * 1.1, 1)]).range([h, 0]);

    // Gridlines
    g.selectAll('.grid-line')
      .data(y.ticks(8))
      .join('line')
      .attr('class', 'grid-line')
      .attr('x1', 0)
      .attr('x2', w)
      .attr('y1', (d) => y(d as number))
      .attr('y2', (d) => y(d as number))
      .attr('stroke', '#374151')
      .attr('stroke-dasharray', '2,2')
      .attr('opacity', 0.2);

    // Baseline (x-axis at y=0)
    const zeroY = y(0);
    g.append('line')
      .attr('x1', 0)
      .attr('x2', w)
      .attr('y1', zeroY)
      .attr('y2', zeroY)
      .attr('stroke', '#6b7280')
      .attr('stroke-width', 2)
      .attr('opacity', 0.8);

    const areaInfl = d3.area<any>().x((d: any) => x(d.year)).y0(y(0)).y1((d: any) => y(d.inflows)).curve(d3.curveMonotoneX);
    const areaInv = d3.area<any>().x((d: any) => x(d.year)).y0(y(0)).y1((d: any) => y(-d.outflowsInvestment)).curve(d3.curveMonotoneX);
    const areaOut = d3.area<any>().x((d: any) => x(d.year)).y0(y(0)).y1((d: any) => y(-d.outflowsOther)).curve(d3.curveMonotoneX);

    g.append('path').datum(rows).attr('fill', 'url(#gradInfl)').attr('d', areaInfl as any);
    g.append('path').datum(rows).attr('fill', 'url(#gradInv)').attr('d', areaInv as any);
    g.append('path').datum(rows).attr('fill', 'url(#gradOut)').attr('d', areaOut as any);

    g.append('path')
      .datum(rows)
      .attr('fill', 'none')
      .attr('stroke', '#10b981')
      .attr('stroke-width', 2.5)
      .attr('d', d3.line<any>().x((d) => x(d.year)).y((d) => y(d.inflows)).curve(d3.curveMonotoneX));

    g.append('path')
      .datum(rows)
      .attr('fill', 'none')
      .attr('stroke', '#14b8a6')
      .attr('stroke-width', 2.5)
      .attr('d', d3.line<any>().x((d) => x(d.year)).y((d) => y(-d.outflowsInvestment)).curve(d3.curveMonotoneX));

    g.append('path')
      .datum(rows)
      .attr('fill', 'none')
      .attr('stroke', '#ef4444')
      .attr('stroke-width', 2.5)
      .attr('d', d3.line<any>().x((d) => x(d.year)).y((d) => y(-d.outflowsOther)).curve(d3.curveMonotoneX));

    // Balance glowing line
    const netLine = d3.line<any>().x((d: any) => x(d.year)).y((d: any) => y(d.balance)).curve(d3.curveMonotoneX);
    g.append('path').datum(rows).attr('fill', 'none').attr('stroke', '#eab308').attr('stroke-width', 8).attr('opacity', 0.28).attr('d', netLine as any).style('filter', 'blur(4px)');
    g.append('path').datum(rows).attr('fill', 'none').attr('stroke', '#eab308').attr('stroke-width', 3.2).attr('d', netLine as any);

    // Dots (no black stroke)
    const sparse = Math.max(1, Math.floor(rows.length / 20));
    g.selectAll('.dot')
      .data(rows.filter((_: any, i: number) => i % sparse === 0))
      .join('circle')
      .attr('cx', (d) => x(d.year))
      .attr('cy', (d) => y(d.balance))
      .attr('r', (d: any) => (d.year === currentYear ? 7 : 4))
      .attr('fill', '#eab308')
      .attr('stroke', 'none')
      .style('filter', (d: any) => (d.year === currentYear ? 'drop-shadow(0 0 6px #eab308)' : 'none'));

    // Cursor line
    const cx = x(currentYear);
    const cursor = g.append('line')
      .attr('x1', cx)
      .attr('x2', cx)
      .attr('y1', 0)
      .attr('y2', h)
      .attr('stroke', '#3b82f6')
      .attr('stroke-width', 3)
      .attr('stroke-dasharray', '8,6')
      .attr('opacity', 0.65)
      .style('filter', 'drop-shadow(0 0 4px #3b82f6)');

    // Axes (years without commas; x-axis drawn at y=0)
    const xAxis = d3.axisBottom(x).ticks(Math.min(10, endYear - startYear)).tickFormat((d: any) => d.toString());
    const yAxis = d3.axisLeft(y).ticks(8).tickFormat((d: any) => `$${(d / 1000).toFixed(0)}k`);

    const gx = g.append('g').attr('transform', `translate(0,${zeroY})`).call(xAxis as any);
    gx.selectAll('text').attr('fill', '#9ca3af').attr('font-size', 11);
    gx.selectAll('line').attr('stroke', '#4b5563');
    gx.select('.domain').attr('stroke', '#4b5563');

    const gy = g.append('g').call(yAxis as any);
    gy.selectAll('text').attr('fill', '#9ca3af').attr('font-size', 11);
    gy.selectAll('line').attr('stroke', '#4b5563');
    gy.select('.domain').attr('stroke', '#4b5563');

    // Interactivity overlay
    if (interactive && onYearSelect) {
      const overlay = g.append('rect')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', w)
        .attr('height', h)
        .attr('fill', 'transparent')
        .style('cursor', 'crosshair') as any;

      function clampYear(ySel: number) {
        return Math.max(startYear, Math.min(endYear, ySel));
      }

      function updateFromX(mx: number) {
        const ySel = Math.round(x.invert(mx));
        const clamped = clampYear(ySel);
        cursor.attr('x1', x(clamped)).attr('x2', x(clamped));
        onYearSelect(clamped);
      }

      overlay
        .on('mousemove', (event: MouseEvent) => {
          const [mx] = d3.pointer(event as any);
          updateFromX(mx);
        })
        .on('click', (event: MouseEvent) => {
          const [mx] = d3.pointer(event as any);
          updateFromX(mx);
        })
        .on('touchstart', (event: any) => {
          const t = event.targetTouches && event.targetTouches[0];
          if (!t) return; const pt = d3.pointer(t, overlay.node());
          updateFromX(pt[0]); event.preventDefault();
        })
        .on('touchmove', (event: any) => {
          const t = event.targetTouches && event.targetTouches[0];
          if (!t) return; const pt = d3.pointer(t, overlay.node());
          updateFromX(pt[0]); event.preventDefault();
        })
        .on('touchend', (event: any) => { event.preventDefault(); });
    }
  }, [refEl, rows, currentYear, startYear, endYear, interactive, onYearSelect]);

  return <div ref={refEl} className="w-full" />;
}